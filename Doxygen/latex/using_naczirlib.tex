\subsection*{Opening a C\+Z\+I-\/file}

The first thing you want to do with a C\+Z\+I-\/file is to open it. This is done with the C\+Z\+I\+Reader-\/object. An instance of a C\+Z\+I\+Reader is created with the function


\begin{DoxyCode}
std::shared\_ptr<ICZIReader> \hyperlink{namespacelib_c_z_i_abe978d8bd50abe94c2d37df6212859e8}{CreateCZIReader}()
\end{DoxyCode}


The C\+Z\+I\+Reader-\/object has the following methods


\begin{DoxyCode}
\textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Open(std::shared\_ptr<IStream> stream);
\textcolor{keyword}{virtual} std::shared\_ptr<IMetadataSegment> ReadMetadataSegment();
\textcolor{keyword}{virtual} std::shared\_ptr<IAccessor> CreateAccessor(AccessorType accessorType);
\textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Close();

\textcolor{comment}{// ... some omitted}
\textcolor{keyword}{virtual} SubBlockStatistics GetStatistics();
\end{DoxyCode}


With the Open-\/method, the caller has to pass in an object which implements the interface \char`\"{}\+I\+Stream\char`\"{}. This object is used by the C\+Z\+I\+Reader in order to access the data in a C\+Z\+I-\/file. It is just the abstraction of a random-\/access stream. \hyperlink{namespacelib_c_z_i}{lib\+C\+ZI} includes a (simple) implementation for reading a file which is constructed by passing in a filename\+:


\begin{DoxyCode}
std::shared\_ptr<IStream> \hyperlink{namespacelib_c_z_i_a8783cf40c0eac418632db90c4f20b43b}{CreateStreamFromFile}(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* szFilename)
\end{DoxyCode}


When the Open-\/method has executed, the sub-\/block directory has been read and parsed, and the remaing methods can be called. This code can be used to open a C\+Z\+I-\/file\+:


\begin{DoxyCode}
\textcolor{keyword}{auto} stream = \hyperlink{namespacelib_c_z_i_a8783cf40c0eac418632db90c4f20b43b}{libCZI::CreateStreamFromFile}(LR\textcolor{stringliteral}{"(D:\(\backslash\)CZI\(\backslash\)sample.czi)");}
\textcolor{stringliteral}{}\textcolor{keyword}{auto} cziReader = \hyperlink{namespacelib_c_z_i_abe978d8bd50abe94c2d37df6212859e8}{libCZI::CreateCZIReader}();
cziReader->Open(stream); 
\end{DoxyCode}


The {\ttfamily Sub\+Block\+Statistics} gives information about the sub-\/blocks in the C\+Z\+I-\/file. The coordinates of each sub-\/block are examined, and the mininum and maximum are determined and are available in the struct returned by the method {\ttfamily I\+Sub\+Block\+Repository\+::\+Get\+Statistics()}. It is usually important to examine the dim\+Bounds member in order to determine which dimensions are used in the C\+Z\+I-\/file.

\subsection*{Reading sub-\/blocks in a C\+Z\+I-\/file}

All the sub-\/blocks in the C\+Z\+I-\/file can be enumerated by the method {\ttfamily I\+Sub\+Block\+Repository\+::\+Enumerate\+Sub\+Blocks}\+:


\begin{DoxyCode}
\textcolor{keyword}{virtual} \textcolor{keywordtype}{void} EnumerateSubBlocks(std::function<\textcolor{keywordtype}{bool}(\textcolor{keywordtype}{int} index, \textcolor{keyword}{const} SubBlockInfo& info)> funcEnum) 
\end{DoxyCode}


This code will print some of the information for all sub-\/blocks contained in a C\+Z\+I-\/file\+:


\begin{DoxyCode}
\textcolor{keyword}{auto} stream = \hyperlink{namespacelib_c_z_i_a8783cf40c0eac418632db90c4f20b43b}{libCZI::CreateStreamFromFile}(LR\textcolor{stringliteral}{"(W:\(\backslash\)Data\(\backslash\)TestData\(\backslash\)DCV\_30MB.czi)")
      ;}
\textcolor{stringliteral}{}\textcolor{keyword}{auto} cziReader = \hyperlink{namespacelib_c_z_i_abe978d8bd50abe94c2d37df6212859e8}{libCZI::CreateCZIReader}();
cziReader->Open(stream);
cziReader->EnumerateSubBlocks(
    [](\textcolor{keywordtype}{int} idx, \textcolor{keyword}{const} \hyperlink{structlib_c_z_i_1_1_sub_block_info}{libCZI::SubBlockInfo}& info)
\{
    cout << \textcolor{stringliteral}{"Index "} << idx << \textcolor{stringliteral}{": "} << \hyperlink{classlib_c_z_i_1_1_utils_aeb42843e65615302b51b68ad2b376e6d}{libCZI::Utils::DimCoordinateToString}
      (&info.\hyperlink{structlib_c_z_i_1_1_sub_block_info_ae4acf2922fe594327d1c6fbfb2062781}{coordinate}) << \textcolor{stringliteral}{" Rect="} << info.logigalRect << endl;
    \textcolor{keywordflow}{return} \textcolor{keyword}{true};
\});
\end{DoxyCode}


It will print out something like\+: \begin{DoxyVerb}...
Index 4: Z4C0T0 Rect=(0,0,512,512)
Index 5: Z5C0T0 Rect=(0,0,512,512)
Index 6: Z6C0T0 Rect=(0,0,512,512)
Index 7: Z7C0T0 Rect=(0,0,512,512)
Index 8: Z8C0T0 Rect=(0,0,512,512)
Index 9: Z9C0T0 Rect=(0,0,512,512)
Index 10: Z10C0T0 Rect=(0,0,512,512)
Index 11: Z11C0T0 Rect=(0,0,512,512)
Index 12: Z12C0T0 Rect=(0,0,512,512)
Index 13: Z13C0T0 Rect=(0,0,512,512)
Index 14: Z14C0T0 Rect=(0,0,512,512)
...
\end{DoxyVerb}


The index argument we got here is used to identify a sub-\/block and can be used with the method {\ttfamily I\+Sub\+Block\+Repository\+::\+Read\+Sub\+Block}. This code will enumerate all sub-\/blocks found in a C\+Z\+I-\/file, read them and save them to a P\+N\+G-\/file\+:


\begin{DoxyCode}
\textcolor{keyword}{auto} stream = \hyperlink{namespacelib_c_z_i_a8783cf40c0eac418632db90c4f20b43b}{libCZI::CreateStreamFromFile}(LR\textcolor{stringliteral}{"(W:\(\backslash\)Data\(\backslash\)TestData\(\backslash\)DCV\_30MB.czi)")
      ;}
\textcolor{stringliteral}{}\textcolor{keyword}{auto} cziReader = \hyperlink{namespacelib_c_z_i_abe978d8bd50abe94c2d37df6212859e8}{libCZI::CreateCZIReader}();
cziReader->Open(stream);
cziReader->EnumerateSubBlocks(
    [&](\textcolor{keywordtype}{int} idx, \textcolor{keyword}{const} \hyperlink{structlib_c_z_i_1_1_sub_block_info}{libCZI::SubBlockInfo}& info)
\{
    \textcolor{keyword}{auto} sbBlk = cziReader->ReadSubBlock(idx);
    \textcolor{keyword}{auto} bitmap = sbBlk->CreateBitmap();
    wstring filename(L\textcolor{stringliteral}{"SubBlock#"});
    filename += to\_wstring(idx);
    filename += L\textcolor{stringliteral}{".PNG"};
    SaveAsPng(filename, bitmap);
    \textcolor{keywordflow}{return} \textcolor{keyword}{true};
\});
\end{DoxyCode}


Note that the function {\ttfamily Save\+As\+Png} is not part of \hyperlink{namespacelib_c_z_i}{lib\+C\+ZI}. It is also worth noting that the {\ttfamily I\+Sub\+Block\+::\+Create\+Bitmap} method will transparently decode the bitmap (in case we have a compressed bitmap in the sub-\/block).

\subsection*{creating multi-\/tile composites}

This piece of code will extract a small rectangular region from a huge multi-\/tile document\+:


\begin{DoxyCode}
\textcolor{keyword}{auto} stream = \hyperlink{namespacelib_c_z_i_a8783cf40c0eac418632db90c4f20b43b}{libCZI::CreateStreamFromFile}(LR\textcolor{stringliteral}{"(
      D:\(\backslash\)PICTURES\(\backslash\)NaCZIrTestData\(\backslash\)Example\_TMA1\_Zeb1\_SPRR2\_Ck19\_S100-1-1-1-1.czi)");}
\textcolor{stringliteral}{}\textcolor{keyword}{auto} cziReader = \hyperlink{namespacelib_c_z_i_abe978d8bd50abe94c2d37df6212859e8}{libCZI::CreateCZIReader}();
cziReader->Open(stream);
\textcolor{keyword}{auto} statistics = cziReader->GetStatistics();
\textcolor{keyword}{auto} accessor = cziReader->CreateSingleChannelTileAccessor();
\hyperlink{classlib_c_z_i_1_1_c_dim_coordinate}{libCZI::CDimCoordinate} planeCoord\{ \{ NaCZIr::DimensionIndex::C,1 \} \};   \textcolor{comment}{// the
       document only contains C-dimension}
\textcolor{keyword}{auto} multiTileComposit = accessor->Get(
    \hyperlink{structlib_c_z_i_1_1_int_rect}{libCZI::IntRect}\{ statistics.boundingBox.\hyperlink{structlib_c_z_i_1_1_int_rect_a7a1e25fc9f6a4c99d9a3710446b7a5de}{x} + 26152, statistics.boundingBox.y + 32215 ,
      3000,2200 \},
    &planeCoord,
    \textcolor{keyword}{nullptr});   \textcolor{comment}{// use default options}
SaveAsPng(LR\textcolor{stringliteral}{"(D:\(\backslash\)TileComposite.png)", multiTileComposit);}
\end{DoxyCode}


Note that we are using the {\ttfamily Sub\+Block\+Statistics} in order to specify a R\+OI with coordinates relative to the upper left corner of the bounding box. The result is depicted here\+:


\begin{DoxyImage}
\includegraphics[width=\textwidth,height=\textheight/2,keepaspectratio=true]{SingleChannelTileAccessor_3.PNG}
\doxyfigcaption{single channel tile accessor}
\end{DoxyImage}


Here is an example which leverages the Single\+Channel\+Scaling\+Tile\+Accessor\+:


\begin{DoxyCode}
\textcolor{keyword}{auto} stream = \hyperlink{namespacelib_c_z_i_a8783cf40c0eac418632db90c4f20b43b}{libCZI::CreateStreamFromFile}(LR\textcolor{stringliteral}{"(
      D:\(\backslash\)PICTURES\(\backslash\)NaCZIrTestData\(\backslash\)Example\_TMA1\_Zeb1\_SPRR2\_Ck19\_S100-1-1-1-1.czi)");}
\textcolor{stringliteral}{}\textcolor{keyword}{auto} cziReader = \hyperlink{namespacelib_c_z_i_abe978d8bd50abe94c2d37df6212859e8}{libCZI::CreateCZIReader}();
cziReader->Open(stream);
\textcolor{keyword}{auto} statistics = cziReader->GetStatistics();
\textcolor{keyword}{auto} accessor = cziReader->CreateSingleChannelScalingTileAccessor();
NaCZIr::CDimCoordinate planeCoord\{ \{ \hyperlink{namespacelib_c_z_i_a55049658acf59d0eddfaebcad16df424a0d61f8370cad1d412f80b84d143e1257}{libCZI::DimensionIndex::C},1 \} \}; \textcolor{comment}{// the
       document only contains C-dimension, we choose channel#1}
\textcolor{keyword}{auto} multiTileComposit = accessor->Get(
    \hyperlink{structlib_c_z_i_1_1_int_rect}{libCZI::IntRect}\{
            statistics.boundingBox.\hyperlink{structlib_c_z_i_1_1_int_rect_a7a1e25fc9f6a4c99d9a3710446b7a5de}{x} + statistics.boundingBox.w / 4,
            statistics.boundingBox.y + statistics.boundingBox.h / 4 ,
            (statistics.boundingBox.w / 8) * 5,
            (statistics.boundingBox.h / 8) * 5 \},
    &planeCoord,
    0.1f,
    \textcolor{keyword}{nullptr});
SaveAsPng(LR\textcolor{stringliteral}{"(D:\(\backslash\)ScalingTileComposite.png)", multiTileComposit);}
\end{DoxyCode}


The R\+OI is now x= $\frac{width}{4}$, y= $\frac{height}{4}$, w= $\frac{5}{8}\cdot width$, h= $\frac{5}{8}\cdot height$ -\/ where $width$ and $height$ refer to the width and height of the bounding box of the document. ~\newline
The zoom is given as 0.\+1 -\/ so the resulting document will have width= $0.1\times\frac{5}{8}\cdot width$ and height=width= $0.1\times\frac{5}{8}\cdot height$.

This operaton is depicted here\+:


\begin{DoxyImage}
\includegraphics[width=\textwidth,height=\textheight/2,keepaspectratio=true]{SingleChannelTileAccessor_4.PNG}
\doxyfigcaption{single channel scaling tile accessor}
\end{DoxyImage}
 \subsection*{creating a multi-\/channel composite}

In order to create a colorful picture from a bunch of channels (usually grayscale), we need to apply a color to it -\/ that\textquotesingle{}s refered to as \char`\"{}tinting\char`\"{}. Furthermore, we want to apply a gradation curve. All the required parameters for this are refered to as \char`\"{}display settings\char`\"{}. In a C\+Z\+I-\/file we can find display settings in the metadata. The following sample is reading the display settings from the metadata; then we get a (scaled) multi-\/tile composite for each of the channels (more exactly\+: only for those channels which are marked \textquotesingle{}active\textquotesingle{} in the display settings). Those bitmaps are then fed into a function which will produce the multi-\/channel-\/composite (according to the display settings).


\begin{DoxyCode}
\textcolor{keyword}{auto} stream = \hyperlink{namespacelib_c_z_i_a8783cf40c0eac418632db90c4f20b43b}{libCZI::CreateStreamFromFile}(LR\textcolor{stringliteral}{"(
      D:\(\backslash\)PICTURES\(\backslash\)NaCZIrTestData\(\backslash\)Example\_TMA1\_Zeb1\_SPRR2\_Ck19\_S100-1-1-1-1.czi)");}
\textcolor{stringliteral}{}\textcolor{keyword}{auto} cziReader = \hyperlink{namespacelib_c_z_i_abe978d8bd50abe94c2d37df6212859e8}{libCZI::CreateCZIReader}();
cziReader->Open(stream);
\textcolor{keyword}{auto} statistics = cziReader->GetStatistics();

\textcolor{comment}{// get the display-setting from the document's metadata}
\textcolor{keyword}{auto} mds = cziReader->ReadMetadataSegment();
\textcolor{keyword}{auto} md = mds->CreateMetaFromMetadataSegment();
\textcolor{keyword}{auto} docInfo = md->GetDocumentInfo();
\textcolor{keyword}{auto} dsplSettings = docInfo->GetDisplaySettings();

\hyperlink{structlib_c_z_i_1_1_int_rect}{libCZI::IntRect} roi\{
    statistics.boundingBox.\hyperlink{structlib_c_z_i_1_1_int_rect_a7a1e25fc9f6a4c99d9a3710446b7a5de}{x} + statistics.boundingBox.w / 4,
    statistics.boundingBox.y + statistics.boundingBox.h / 4 ,
    (statistics.boundingBox.w / 8) * 5, (statistics.boundingBox.h / 8) * 5 \};

\textcolor{comment}{// get the tile-composite for all channels (which are marked 'active' in the display-settings)}
std::vector<shared\_ptr<libCZI::IBitmapData>> actvChBms;
\textcolor{keywordtype}{int} index = 0;  \textcolor{comment}{// index counting only the active channels}
std::map<int, int> activeChNoToChIdx;   \textcolor{comment}{// we need to keep track which 'active channels" corresponds to
       which channel index}
\textcolor{keyword}{auto} accessor = cziReader->CreateSingleChannelScalingTileAccessor();
libCZI::CDisplaySettingsHelper::EnumEnabledChannels(dsplSettings.get(),
    [&](\textcolor{keywordtype}{int} chIdx)->\textcolor{keywordtype}{bool}
\{
    \hyperlink{classlib_c_z_i_1_1_c_dim_coordinate}{libCZI::CDimCoordinate} planeCoord\{ \{ 
      \hyperlink{namespacelib_c_z_i_a55049658acf59d0eddfaebcad16df424a0d61f8370cad1d412f80b84d143e1257}{libCZI::DimensionIndex::C}, chIdx \} \};
    actvChBms.emplace\_back(accessor->Get(roi, &planeCoord, 0.05f, \textcolor{keyword}{nullptr}));
    activeChNoToChIdx[chIdx] = index++;
    \textcolor{keywordflow}{return} \textcolor{keyword}{true};
\});

\textcolor{comment}{// initialize the helper with the display-settings and provide the pixeltypes }
\textcolor{comment}{// (for each active channel)}
libCZI::CDisplaySettingsHelper dsplHlp;
dsplHlp.Initialize(dsplSettings.get(), 
    [&](\textcolor{keywordtype}{int} chIdx)->\hyperlink{namespacelib_c_z_i_abf8ce12ab88b06c8b3b47efbb5e2e834}{libCZI::PixelType} \{ \textcolor{keywordflow}{return} actvChBms[activeChNoToChIdx[chIdx]]->
      GetPixelType(); \});

\textcolor{comment}{// pass the tile-composites we just created (and the display-settings for the those active }
\textcolor{comment}{//  channels) into the multi-channel-composor-function}
\textcolor{keyword}{auto} mcComposite = \hyperlink{classlib_c_z_i_1_1_compositors_ab9be96d1b2b2e48c60c4dbf967e593c1}{libCZI::Compositors::ComposeMultiChannel\_Bgr24}
      (
    dsplHlp.GetActiveChannelsCount(),
    std::begin(actvChBms),
    dsplHlp.GetChannelInfosArray());

SaveAsPng(LR\textcolor{stringliteral}{"(D:\(\backslash\)ScalingTileComposite\_MultiChannelComposite.png)", mcComposite);}
\end{DoxyCode}


In this sample we used the same document and R\+OI as before. The C\+Z\+I-\/file in this case contained 5 channels (and all being \textquotesingle{}active\textquotesingle{}), so we had to get 5 tile-\/composites (using the Single\+Channel\+Scaling\+Tile\+Accessor), which are then all put into the {\ttfamily Compose\+Multi\+Channel\+\_\+\+Bgr24} function (alongside with the corresponding display-\/settings). The function will produce a new bitmap (always of pixeltype Bgr24) which then contains the multi-\/channel-\/composite image. In this process we leveraged a utility {\ttfamily C\+Display\+Settings\+Helper} which hides some of the book-\/keeping (among other things, it helps sorting out the \textquotesingle{}active\textquotesingle{} channels and it converts the display-\/settings we got from the document\textquotesingle{}s metadata into the form expected by the {\ttfamily Compose\+Multi\+Channel\+\_\+\+Bgr24} function).

The complete operation is depicted here\+:


\begin{DoxyImage}
\includegraphics[width=\textwidth,height=\textheight/2,keepaspectratio=true]{ScalingSingleChannelTileAccessor1.png}
\doxyfigcaption{multi-\/channel-\/composite from a (scaled) tile-\/composite}
\end{DoxyImage}
 